########################
# Purpose of this code #
########################
# This code illustrates how to calculate the bispectrum and 3PCF using "$WORK/cosmo/hitomi_theory".
# The bispectrum is computed using perturbation solutions for fluctuations up to the second-order. For nonlinear effects higher than the second-order, this code takes into account only the damping effect of BAO. In addition, it is possible to calculate the second-order fluctuations and the BAO damping effect after reconstruction.
# This code also computes the galaxy bispectrum generated by primordial non-Gaussianities.
######################################################

#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os, sys
import numpy as np

from classy import Class

# $WORK/cosmo/hitomi_theory/ #
import fiducial
import initial
#import powerspec
import bispec

import time

start = time.time()

ell1 = int(sys.argv[1])
ell2 = int(sys.argv[2])
ELL  = int(sys.argv[3])

#ell1 = 0
#ell2 = 0
#ELL = 0

print("ell1 =", ell1)
print("ell2 =", ell2)
print("ELL =", ELL)

# Redshift #
zbin = 1 # 1,3
if zbin == 1:
    redshift = 0.38 
elif zbin == 3:
    redshift = 0.61

# r-bin #
rbin = np.linspace(30.0, 150.0, 13)
# k-bin #
kbin = np.linspace(0.02, 0.2, 10)

##################################################################################################################################
# BOSS fiducial parameters #
# The values of the fiducial parameters should be exactly the same as those used to calculate the distance to the BOSS galaxies.
# (see $WORK/data/boss/fits2dat_galaxy.py)
##################################################################################################################################
params_cosmo = {
    'h': 0.676,
    'omega_b': 0.022,
    'omega_cdm': 0.11966256,
    'n_s': 0.96,
    'ln10^{10}A_s': 3.094,
    'tau_reio': 0.0826026,
    
    'N_ur': 2.0328,
    'N_ncdm': 1,
    'm_ncdm': 0.06,
    'T_ncdm': 0.71611,

    'output': 'tCl, mPk',
    'P_k_max_h/Mpc': 50.0,
    'z_max_pk': 3.0,
}

##############################################################################################
# To calculate the AP parameters, we use the fiducial cosmology parameters to calculate 
# the angular diameter distance (Da_fid) and the Hubble parameter (H_fid) at a given redshift.
##############################################################################################
fiducial_cosmo = fiducial.FiducialHubbleParameterAndAngularDiameterDistance(redshift, params_cosmo)
fiducial_cosmo.calcHubbleParameterAndAngularDiameterDistance()
Da_fid = fiducial_cosmo.getFiducialAngularDiameterDistance()
H_fid = fiducial_cosmo.getFiducialHubbleParameter()

###############
# Call Class() 
###############
cosmo = Class()
cosmo.set(params_cosmo)
cosmo.compute()

###############
# Compute the required functions:
# the linear matter power spectrum, the no-wiggle linear matter power spectrum,
# the growth factor, the growth rate, sigma8 at a given redshift, 
# and the Alcock-Paczyn'ski parameters.
###############
initial_cosmo = initial.InputPowerSpectrum(redshift, cosmo)
initial_cosmo.calcMatterPowerSpectrum()
initial_cosmo.calcNoWiggleMatterPowerSpectrum()
initial_cosmo.calcPrimordialPowerSpectrum(ln10A_s10 = params_cosmo["ln10^{10}A_s"], n_s = params_cosmo["n_s"])

k_in, pk_in = initial_cosmo.getMatterPowerSpectrum()
k_in, pk_nw_in = initial_cosmo.getNoWiggleMatterPowerSpectrum()
k_in, mk_pri_in = initial_cosmo.getTransferFunctionM()
Dz = initial_cosmo.getGrowthFactor()
fz = initial_cosmo.getGrowthRate()
alpha_perp = initial_cosmo.getAlphaPerp(Da_fid)
alpha_parallel = initial_cosmo.getAlphaParallel(H_fid)
sigma8z_norm = initial_cosmo.getSigma8ForNormalization()
sigma8z = sigma8z_norm # If the value of sigma8(z=0) is already known, such as in the case of simulated data, use sigma8z = Dz * sigma8(z=0).

print()
print("alpha_perp =", alpha_perp)
print("alpha_parallel =", alpha_parallel)
print("Growth factor =", Dz)
print("Growth rate =", fz)
print("sigma8(z) =", sigma8z)

b1 = 2.0
b2 = 0.0
bK2 = 0.0
fsigma8 = fz * sigma8z
b1sigma8 = b1 * sigma8z

print("fsigma8 =",  fsigma8)
print("b1sigma8 =", b1sigma8)
print()

###############################################
# Calculate the bispectrum and three-point correlation function 
###############################################
# When ignoring the RSD effect, set fz = 0
# For dark matter, set b1 = b2 = bK2 = 0.
params = {
    'alpha_perp': alpha_perp,
    'alpha_parallel': alpha_parallel,
    'sigma8': sigma8z,
    'fz': fsigma8/sigma8z,
    'b1': b1sigma8/sigma8z,

    # For the bispectrum and 3PCF, add the second-order bias parameters, 
    # where "b2" is the nonlinear local bias and "bK2" is the non-local tidal bias.
    'b2': b2,
    'bK2': bK2,
}

# Call "ClassBiSpectrum()"
B = bispec.ClassBiSpectrum()
# Input linear power spectra
B.set_input_pk(k_in, pk_in)
B.set_input_pk_nw(k_in, pk_nw_in)
# Set "sigma8" used to nomalize the input linear power spectrum.
B.set_normalization(sigma8z_norm)
# Set input parameters 
B.set_params(params)
 
# make an output directory #
output_dir = "results_test"
try:
    os.mkdir(output_dir)
except:
    pass

### ##################################
### # From here, we calculate the multipole components of the bispectrum and their inverse Fourier transforms, 3PCF multipoles.
### #
### # First of all, the "name" parameter specifies the type of bispectra to calculate.
### # All possible "name" parameters are the following: 
### # "Tree" means the tree-level bispectrum;
### # "Tree_NoWiggle" means the no-wiggle tree-level bispectrum;
### # "Tree_BAO" means the tree-level bispectrum with the damping effect of the BAO signal, proposed by Sugiyama et al.2021;
### # "Tree_BAO_Reconstructed" is the reconstructed verion of "Tree_BAO";
### # "Tree_BAO_Template" is a decomposition of "Tree_BAO" into parts that do not depend on the varying parameters in "montepython";
### # "Tree_NonGaussian_Local", "Tree_NonGaussian_Equilateral", "Tree_NonGaussian_Orthogonal" are the bispectra generated by the primordial non-Gaussianity of the local, equilateral, and orthogonal types.
### #
### # The "kbin" parameter specifies the binning of the bispectrum to be calculated.
### # For example, kbin = np.linspace(0.02, 0.2, 10).
### #
### # The "ell1", "ell2", and "ELL" parameters specify the multipole component to be calculated.
### # The possible combinations of (ell1, ell2, ELL) with non-zero multipole components are: 
### # in the monopole case, (ell1, ell2, ELL) are (0,0,0), (1,1,0), (2,2,0), (3,3,0), (4,4,0), etc.;
### # in the quadrupole case, (ell1, ell2, ELL) are (2,0,2), (0,2,2), (1,1,2), (3,1,2), (1,3,2), (2,2,2), etc.;
### # in the hexadecapole case, (ell1, ell2, ELL) are (4,0,4), (3,1,4), (2,2,4), (1,3,4), (0,4,4), etc.
### #
### 
### #####
### # The simplest example is to compute the tree-level bispectrum multipoles.
### name = "Tree"
### bk_dict = B.calc_B(name=name, kbin = kbin, ell1=ell1, ell2=ell2, ELL=ELL)
### print(bk_dict.keys()) # dict_keys(['kbin1', 'kbin2', 'B', 'kbin1_fft', 'kbin2_fft', 'B_fft', 'ell1', 'ell2', 'ELL', 'flag_3pcf', 'flag_BAO', 'flag_recon', 'sigma2_perp', 'sigma2_para'])
### # Save the results.
### k_len = len(bk_dict["kbin1"])
### X = np.array([bk_dict["kbin1"].reshape(k_len**2),\
###               bk_dict["kbin2"].reshape(k_len**2),\
###               bk_dict["B"].reshape(k_len**2)]).T
### np.savetxt("%s/bk%d%d%d_%s.dat" % (output_dir, ell1, ell2, ELL, name), X, fmt="%.5f \t %.5f \t %.7e" )

### ########################
### ## Calculate the 3PCF from the bispectrum through the 2D Hankel transform. k1 and k2, on which the bispectrum depends, are calculated in the range of 0.0003<k1<10 [h/Mpc] and 0.0003<k2<10 [h/Mpc], respectively, to perform the 2D Hankel transform. The number of k1- and k2-bins is set to 150, so the number of k-bins required for the 2D Hankel transform is 150*150=22,500. In order to calculate the bispectrum multipole for a single bin, triple integration is required. Thus, computing 22,500 triple integrals take approximately 30 minutes to an hour.
### 
### name = "Tree"
### bk_dict = B.calc_B(name=name, kbin = kbin, ell1=ell1, ell2=ell2, ELL=ELL, flag_3pcf=True)
### print(bk_dict.keys()) # dict_keys(['kbin1', 'kbin2', 'B', 'kbin1_fft', 'kbin2_fft', 'B_fft', 'ell1', 'ell2', 'ELL', 'flag_3pcf', 'flag_BAO', 'flag_recon', 'sigma2_perp', 'sigma2_para'])
### # Save the results.
### k_len = len(bk_dict["kbin1"])
### X = np.array([bk_dict["kbin1"].reshape(k_len**2),\
###               bk_dict["kbin2"].reshape(k_len**2),\
###               bk_dict["B"].reshape(k_len**2)]).T
### np.savetxt("%s/bk%d%d%d_%s.dat" % (output_dir, ell1, ell2, ELL, name), X, fmt="%.5f \t %.5f \t %.7e" )
### 
### k_len = len(bk_dict["kbin1_fft"])
### X = np.array([bk_dict["kbin1_fft"].reshape(k_len**2),\
###               bk_dict["kbin2_fft"].reshape(k_len**2),\
###               bk_dict["B_fft"].reshape(k_len**2)]).T
### np.savetxt("%s/bk%d%d%d_%s_fft.dat" % (output_dir, ell1, ell2, ELL, name), X, fmt="%.5f \t %.5f \t %.7e" )
### 
### # The "calc_B_to_3PCF" function, which calculates the 3PCF, returns a directory object.
### # Input "rbin", e.g., rbin = np.linspace(30, 150, 13)
### zeta_dict = B.calc_B_to_3PCF(bk_dict, rbin=rbin)
### # Print the keys contained in "zeta_dict".
### print(zeta_dict.keys()) 
### # To get the resulting 3PCF corresponding to the input "rbin", use "rbin" and "3pcf".
### # Save the results.
### r_len = len(zeta_dict["rbin1"])
### X = np.array([zeta_dict["rbin1"].reshape(r_len**2),\
###               zeta_dict["rbin2"].reshape(r_len**2),\
###               zeta_dict["3pcf"].reshape(r_len**2)]).T
### np.savetxt("%s/zeta%d%d%d_%s.dat" % (output_dir, ell1, ell2, ELL, name), X, fmt="%.5f \t %.5f \t %.7e")
### 
### r_len = len(zeta_dict["rbin1_fft"])
### X = np.array([zeta_dict["rbin1_fft"].reshape(r_len**2),\
###               zeta_dict["rbin2_fft"].reshape(r_len**2),\
###               zeta_dict["3pcf_fft"].reshape(r_len**2)]).T
### np.savetxt("%s/zeta%d%d%d_%s_fft.dat" % (output_dir, ell1, ell2, ELL, name), X, fmt="%.5f \t %.5f \t %.7e")
### 
### ######
### # The "calc_3PCF_to_B" function computes the bispectrum from the 3PCF. 
### # This calculation is useful when performing window function corrections to the bispectrum.
### bk_dict_from_3pcf = B.calc_3PCF_to_B(zeta_dict, kbin=kbin)
### print(bk_dict_from_3pcf.keys())
### # Save the results.
### k_len = len(bk_dict_from_3pcf["kbin1"])
### X = np.array([bk_dict_from_3pcf["kbin1"].reshape(k_len**2),\
###               bk_dict_from_3pcf["kbin2"].reshape(k_len**2),\
###               bk_dict_from_3pcf["B"].reshape(k_len**2)]).T
### np.savetxt("%s/bk%d%d%d_%s_from_3pcf.dat" % (output_dir, ell1, ell2, ELL, name), X, fmt="%.5f \t %.5f \t %.7e" )
### ######
### 
### ############################
### # Calculate the no-wiggle bispectrum multipoles 
### name="Tree_NoWiggle"
### bk_dict = B.calc_B(name=name, kbin = kbin, ell1=ell1, ell2=ell2, ELL=ELL, flag_3pcf=True)
### zeta_dict = B.calc_B_to_3PCF(bk_dict, rbin=rbin)
### k_len = len(bk_dict["kbin1_fft"])
### r_len = len(zeta_dict["rbin1_fft"])
### np.savetxt("%s/bk%d%d%d_%s_fft.dat" % (output_dir, ell1, ell2, ELL, name),\
###         np.array([bk_dict["kbin1_fft"].reshape(k_len**2),\
###                   bk_dict["kbin2_fft"].reshape(k_len**2),\
###                   bk_dict["B_fft"].reshape(k_len**2)]).T, fmt="%.5f \t %.5f \t %.7e" )
### np.savetxt("%s/zeta%d%d%d_%s_fft.dat" % (output_dir, ell1, ell2, ELL, name),\
###         np.array([zeta_dict["rbin1_fft"].reshape(r_len**2),\
###                   zeta_dict["rbin2_fft"].reshape(r_len**2),\
###                   zeta_dict["3pcf_fft"].reshape(r_len**2)]).T, fmt="%.5f \t %.5f \t %.7e")
### 
### ###################
### # Calculate the bispectrum model describing the damping of the BAO signal given by Sugiyama et al. 2021.
### # When calculating "Tree_BAO", add "flag_BAO=True".
### name="Tree_BAO"
### bk_dict = B.calc_B(name=name, kbin = kbin, ell1=ell1, ell2=ell2, ELL=ELL, flag_BAO=True, flag_3pcf=True)
### zeta_dict = B.calc_B_to_3PCF(bk_dict, rbin=rbin)
### k_len = len(bk_dict["kbin1_fft"])
### r_len = len(zeta_dict["rbin1_fft"])
### np.savetxt("%s/bk%d%d%d_%s_fft.dat" % (output_dir, ell1, ell2, ELL, name),\
###         np.array([bk_dict["kbin1_fft"].reshape(k_len**2),\
###                   bk_dict["kbin2_fft"].reshape(k_len**2),\
###                   bk_dict["B_fft"].reshape(k_len**2)]).T, fmt="%.5f \t %.5f \t %.7e" )
### np.savetxt("%s/zeta%d%d%d_%s_fft.dat" % (output_dir, ell1, ell2, ELL, name),\
###         np.array([zeta_dict["rbin1_fft"].reshape(r_len**2),\
###                   zeta_dict["rbin2_fft"].reshape(r_len**2),\
###                   zeta_dict["3pcf_fft"].reshape(r_len**2)]).T, fmt="%.5f \t %.5f \t %.7e")
### 
### ######
### # Compute the reconstructed model.
### # Here, we assume that only the values of "sigma2_perp" and "sigma2_para" are changed by reconstruction. 
### # The reconstructed "sigma2_perp" and "sigma2_para" are computed by linear Lagrangian perturbation theory.
### # Add "flag_recon=True".
### # The input parameters are the linear bias parameter (b1_fid) and the Gaussian smoothing parameter (R). 
### # These values must be exactly the same as those used to reconstruct the data.
### #
### b1_fid = 2.0
### for R in [5, 10, 15, 20]:
###     
###     name="Tree_BAO_Reconstructed"
###     bk_dict = B.calc_B(name=name, kbin = kbin, ell1=ell1, ell2=ell2, ELL=ELL, flag_BAO=True, flag_3pcf=True, flag_recon=True, one_over_b1_fid = 1.0 / b1_fid, R = R)
###     zeta_dict = B.calc_B_to_3PCF(bk_dict, rbin=rbin)
###     k_len = len(bk_dict["kbin1_fft"])
###     r_len = len(zeta_dict["rbin1_fft"])
###     np.savetxt("%s/bk%d%d%d_%s_R%02d_fft.dat" % (output_dir, ell1, ell2, ELL, name, R),\
###             np.array([bk_dict["kbin1_fft"].reshape(k_len**2),\
###                       bk_dict["kbin2_fft"].reshape(k_len**2),\
###                       bk_dict["B_fft"].reshape(k_len**2)]).T, fmt="%.5f \t %.5f \t %.7e" )
###     np.savetxt("%s/zeta%d%d%d_%s_R%02d_fft.dat" % (output_dir, ell1, ell2, ELL, name, R),\
###             np.array([zeta_dict["rbin1_fft"].reshape(r_len**2),\
###                       zeta_dict["rbin2_fft"].reshape(r_len**2),\
###                       zeta_dict["3pcf_fft"].reshape(r_len**2)]).T, fmt="%.5f \t %.5f \t %.7e")
###     
### ######
### ## Decompose the bispectrum (3PCF) computed by "Tree_BAO" into terms independent of parameters characterizing the non-linearity. Then, "Tree_BAO" is decomposed into 22 components. Here, "name" is fixed to "Tree_BAO_Template", and a new parameter "param_name" is added.
### 
### PARAM_NAME = []
### PARAM_NAME.append("FG_b3_f0")
### PARAM_NAME.append("FS_b3_f0")
### PARAM_NAME.append("FT_b3_f0")
### PARAM_NAME.append("FG_b2_f1")
### PARAM_NAME.append("FS_b2_f1")
### PARAM_NAME.append("FT_b2_f1")
### PARAM_NAME.append("FG_b1_f2")
### PARAM_NAME.append("FS_b1_f2")
### PARAM_NAME.append("FT_b1_f2")
### 
### PARAM_NAME.append("GG_b2_f1")
### PARAM_NAME.append("GS_b2_f1")
### PARAM_NAME.append("GT_b2_f1")
### PARAM_NAME.append("GG_b1_f2")
### PARAM_NAME.append("GS_b1_f2")
### PARAM_NAME.append("GT_b1_f2")
### PARAM_NAME.append("GG_b0_f3")
### PARAM_NAME.append("GS_b0_f3")
### PARAM_NAME.append("GT_b0_f3")
### 
### PARAM_NAME.append("b3_f1")
### PARAM_NAME.append("b2_f2")
### PARAM_NAME.append("b1_f3")
### PARAM_NAME.append("b0_f4")
### 
### ## In General Relativity, the values of the above parameters are as follows.
### FG = (17.0/21.0 + (1.0/2.0) * (b2/b1)) * sigma8z
### FS = (1.0) * sigma8z
### FT = (2.0/7.0 + (bK2/b1)) * sigma8z
### GG = (13.0/21.0) * sigma8z
### GS = (1.0) * sigma8z
### GT = (4.0/7.0) * sigma8z
### 
### PARAM = []
### PARAM.append(FG * b1sigma8**3)
### PARAM.append(FS * b1sigma8**3)
### PARAM.append(FT * b1sigma8**3)
### PARAM.append(FG * b1sigma8**2 * fsigma8)
### PARAM.append(FS * b1sigma8**2 * fsigma8)
### PARAM.append(FT * b1sigma8**2 * fsigma8)
### PARAM.append(FG * b1sigma8 * fsigma8**2)
### PARAM.append(FS * b1sigma8 * fsigma8**2)
### PARAM.append(FT * b1sigma8 * fsigma8**2)
### 
### PARAM.append(GG * b1sigma8**2 * fsigma8)
### PARAM.append(GS * b1sigma8**2 * fsigma8)
### PARAM.append(GT * b1sigma8**2 * fsigma8)
### PARAM.append(GG * b1sigma8**1 * fsigma8**2)
### PARAM.append(GS * b1sigma8**1 * fsigma8**2)
### PARAM.append(GT * b1sigma8**1 * fsigma8**2)
### PARAM.append(GG * fsigma8**3)
### PARAM.append(GS * fsigma8**3)
### PARAM.append(GT * fsigma8**3)
### 
### PARAM.append(b1sigma8**3 * fsigma8)
### PARAM.append(b1sigma8**2 * fsigma8**2)
### PARAM.append(b1sigma8 * fsigma8**3)
### PARAM.append(fsigma8**4)
### 
### k_len = len(kbin)
### r_len = len(rbin)
### bk = np.zeros((k_len, k_len))
### zeta = np.zeros((r_len, r_len))
### 
### for p, param_name in enumerate(PARAM_NAME):
###     
###     name="Tree_BAO_Template"
###     bk_dict = B.calc_B(name=name, kbin = kbin, ell1=ell1, ell2=ell2, ELL=ELL, flag_BAO=True, flag_3pcf=True, param_name=param_name)
###     zeta_dict = B.calc_B_to_3PCF(bk_dict, rbin=rbin)
###     k_len = len(bk_dict["kbin1_fft"])
###     r_len = len(zeta_dict["rbin1_fft"])
###     np.savetxt("%s/bk%d%d%d_%s_%s_fft.dat" % (output_dir, ell1, ell2, ELL, name, param_name),\
###             np.array([bk_dict["kbin1_fft"].reshape(k_len**2),\
###                       bk_dict["kbin2_fft"].reshape(k_len**2),\
###                       PARAM[p] * bk_dict["B_fft"].reshape(k_len**2)]).T, fmt="%.5f \t %.5f \t %.7e" )
###     np.savetxt("%s/zeta%d%d%d_%s_%s_fft.dat" % (output_dir, ell1, ell2, ELL, name, param_name),\
###             np.array([zeta_dict["rbin1_fft"].reshape(r_len**2),\
###                       zeta_dict["rbin2_fft"].reshape(r_len**2),\
###                       PARAM[p] * zeta_dict["3pcf_fft"].reshape(r_len**2)]).T, fmt="%.5f \t %.5f \t %.7e")
###  
###     bk = bk + PARAM[p] * bk_dict["B"]
###     zeta = zeta + PARAM[p] * zeta_dict["3pcf"]
### 
### name="Tree_BAO"
### bk_dict = B.calc_B(name=name, kbin = kbin, ell1=ell1, ell2=ell2, ELL=ELL, flag_BAO=True, flag_3pcf=True, param_name=param_name)
### zeta_dict = B.calc_B_to_3PCF(bk_dict, rbin=rbin)
### 
### print()
### print("sum(diff.) =", np.sum(bk_dict["B"] - bk)/np.sum(bk))
### print("sum(diff.) =", np.sum(zeta_dict["3pcf"] - zeta)/np.sum(zeta))
### print()
### 
### ############################
### ## Calculate the bispectrum generated by primordial non-Gaussianities. The bispectrum computed here is the term proportional to the fNL parameter. Therefore, the final result should be fNL * bk_dict["B"]. In other words, the results here correspond to the case where fNL = 1.
### ############################
### for name in ["Tree_NonGaussian_Local", "Tree_NonGaussian_Equilateral", "Tree_NonGaussian_Orthogonal"]:
###     
###     bk_dict = B.calc_B(name=name, kbin = kbin, ell1=ell1, ell2=ell2, ELL=ELL, flag_3pcf=True, flag_PNG = True, k_pri=k_in, mk_pri=mk_pri_in)
###     zeta_dict = B.calc_B_to_3PCF(bk_dict, rbin=rbin)
###     k_len = len(bk_dict["kbin1_fft"])
###     r_len = len(zeta_dict["rbin1_fft"])
###     np.savetxt("%s/bk%d%d%d_%s_fft.dat" % (output_dir, ell1, ell2, ELL, name),\
###             np.array([bk_dict["kbin1_fft"].reshape(k_len**2),\
###                       bk_dict["kbin2_fft"].reshape(k_len**2),\
###                       bk_dict["B_fft"].reshape(k_len**2)]).T, fmt="%.5f \t %.5f \t %.7e" )
###     np.savetxt("%s/zeta%d%d%d_%s_fft.dat" % (output_dir, ell1, ell2, ELL, name),\
###             np.array([zeta_dict["rbin1_fft"].reshape(r_len**2),\
###                       zeta_dict["rbin2_fft"].reshape(r_len**2),\
###                       zeta_dict["3pcf_fft"].reshape(r_len**2)]).T, fmt="%.5f \t %.5f \t %.7e")
### 
end = time.time() - start
print("END: %f sec." % end)


